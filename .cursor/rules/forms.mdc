---
description: Advanced form patterns with React Hook Form and Zod validation for DataParseDesk
globs: src/components/**/*Form*.tsx, src/components/**/*Dialog.tsx
alwaysApply: false
---

- **Form Library Stack:**
  - **Forms:** React Hook Form
  - **Validation:** Zod
  - **UI:** shadcn/ui Form components
  - From [package.json](mdc:package.json): `react-hook-form`, `@hookform/resolvers`, `zod`

- **Basic Form Setup:**

  **1. Simple Form with Validation**
  Reference: [ProjectFormDialog.tsx](mdc:src/components/database/ProjectFormDialog.tsx)

  ```typescript
  import { useForm } from 'react-hook-form';
  import { zodResolver } from '@hookform/resolvers/zod';
  import { z } from 'zod';
  import {
    Form,
    FormControl,
    FormDescription,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
  } from '@/components/ui/form';
  import { Input } from '@/components/ui/input';
  import { Button } from '@/components/ui/button';

  // ✅ DO: Define schema first
  const projectSchema = z.object({
    name: z.string()
      .min(1, 'Название обязательно')
      .max(100, 'Максимум 100 символов')
      .trim(),
    description: z.string()
      .max(1000, 'Максимум 1000 символов')
      .optional()
      .nullable(),
    is_public: z.boolean().default(false),
  });

  type ProjectFormData = z.infer<typeof projectSchema>;

  function ProjectForm({ onSubmit, defaultValues }: {
    onSubmit: (data: ProjectFormData) => Promise<void>;
    defaultValues?: Partial<ProjectFormData>;
  }) {
    const form = useForm<ProjectFormData>({
      resolver: zodResolver(projectSchema),
      defaultValues: {
        name: '',
        description: '',
        is_public: false,
        ...defaultValues,
      },
    });

    const handleSubmit = async (data: ProjectFormData) => {
      try {
        await onSubmit(data);
        form.reset();
      } catch (error) {
        // Error handled by parent
      }
    };

    return (
      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Название проекта</FormLabel>
                <FormControl>
                  <Input
                    placeholder="Введите название"
                    {...field}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="description"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Описание</FormLabel>
                <FormControl>
                  <textarea
                    className="w-full min-h-[100px] px-3 py-2 border border-input rounded-md"
                    placeholder="Описание проекта..."
                    {...field}
                    value={field.value || ''}
                  />
                </FormControl>
                <FormDescription>
                  Необязательное описание проекта
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="is_public"
            render={({ field }) => (
              <FormItem className="flex items-center gap-2">
                <FormControl>
                  <input
                    type="checkbox"
                    checked={field.value}
                    onChange={field.onChange}
                    className="h-4 w-4"
                  />
                </FormControl>
                <FormLabel className="!mt-0">Публичный проект</FormLabel>
              </FormItem>
            )}
          />

          <div className="flex justify-end gap-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => form.reset()}
            >
              Сбросить
            </Button>
            <Button
              type="submit"
              disabled={form.formState.isSubmitting}
            >
              {form.formState.isSubmitting ? 'Сохранение...' : 'Сохранить'}
            </Button>
          </div>
        </form>
      </Form>
    );
  }
  ```

- **Advanced Validation:**

  **1. Complex Validation Rules**
  ```typescript
  // ✅ DO: Use Zod's advanced features
  const columnSchema = z.object({
    name: z.string()
      .min(1, 'Название обязательно')
      .max(50)
      .regex(/^[a-zA-Z0-9_]+$/, 'Только буквы, цифры и подчеркивание'),

    type: z.enum(['text', 'number', 'date', 'boolean', 'select', 'multiselect'], {
      errorMap: () => ({ message: 'Выберите тип колонки' }),
    }),

    is_required: z.boolean(),

    // Conditional validation
    options: z.array(z.object({
      value: z.string(),
      label: z.string(),
    })).optional(),

    default_value: z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.null(),
    ]).optional(),
  }).superRefine((data, ctx) => {
    // Custom validation: select types must have options
    if ((data.type === 'select' || data.type === 'multiselect') &&
        (!data.options || data.options.length === 0)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Выберите хотя бы один вариант',
        path: ['options'],
      });
    }

    // Type-safe default value validation
    if (data.default_value !== null && data.default_value !== undefined) {
      if (data.type === 'number' && typeof data.default_value !== 'number') {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: 'Значение по умолчанию должно быть числом',
          path: ['default_value'],
        });
      }
    }
  });
  ```

  **2. Async Validation**
  ```typescript
  // ✅ DO: Use resolver for sync, useEffect for async
  const databaseSchema = z.object({
    name: z.string().min(1),
    project_id: z.string().uuid(),
  });

  function DatabaseForm() {
    const form = useForm<DatabaseFormData>({
      resolver: zodResolver(databaseSchema),
    });

    const name = form.watch('name');

    // Async validation: check if name exists
    useEffect(() => {
      if (!name || name.length < 2) return;

      const timeoutId = setTimeout(async () => {
        const exists = await checkDatabaseNameExists(name);

        if (exists) {
          form.setError('name', {
            type: 'manual',
            message: 'База данных с таким именем уже существует',
          });
        } else {
          form.clearErrors('name');
        }
      }, 500); // Debounce

      return () => clearTimeout(timeoutId);
    }, [name, form]);

    // ...
  }
  ```

- **Form Dialog Pattern:**

  **1. Dialog with Form**
  ```typescript
  import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
  import { useState } from 'react';

  function CreateProjectDialog({ onSuccess }: {
    onSuccess: () => void;
  }) {
    const [open, setOpen] = useState(false);
    const createProject = useCreateProject();

    const handleSubmit = async (data: ProjectFormData) => {
      await createProject.mutateAsync(data);
      setOpen(false);
      onSuccess();
    };

    return (
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogTrigger asChild>
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            Создать проект
          </Button>
        </DialogTrigger>

        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Новый проект</DialogTitle>
          </DialogHeader>

          <ProjectForm onSubmit={handleSubmit} />
        </DialogContent>
      </Dialog>
    );
  }
  ```

- **Dynamic Forms:**

  **1. Array Fields**
  ```typescript
  import { useFieldArray } from 'react-hook-form';
  import { Plus, X } from 'lucide-react';

  const tagSchema = z.object({
    tags: z.array(z.object({
      value: z.string().min(1, 'Тег не может быть пустым'),
    })).min(1, 'Добавьте хотя бы один тег'),
  });

  function TagForm() {
    const form = useForm({
      resolver: zodResolver(tagSchema),
      defaultValues: {
        tags: [{ value: '' }],
      },
    });

    const { fields, append, remove } = useFieldArray({
      control: form.control,
      name: 'tags',
    });

    return (
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <div className="space-y-4">
            {fields.map((field, index) => (
              <FormField
                key={field.id}
                control={form.control}
                name={`tags.${index}.value`}
                render={({ field }) => (
                  <FormItem>
                    <div className="flex gap-2">
                      <FormControl>
                        <Input placeholder="Введите тег" {...field} />
                      </FormControl>

                      {fields.length > 1 && (
                        <Button
                          type="button"
                          variant="ghost"
                          size="icon"
                          onClick={() => remove(index)}
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />
            ))}

            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => append({ value: '' })}
            >
              <Plus className="h-4 w-4 mr-2" />
              Добавить тег
            </Button>
          </div>

          <Button type="submit">Сохранить</Button>
        </form>
      </Form>
    );
  }
  ```

  **2. Conditional Fields**
  ```typescript
  // ✅ DO: Show/hide fields based on other fields
  function ColumnForm() {
    const form = useForm<ColumnFormData>({
      resolver: zodResolver(columnSchema),
    });

    const columnType = form.watch('type');

    return (
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          <FormField
            control={form.control}
            name="type"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Тип колонки</FormLabel>
                <Select onValueChange={field.onChange} value={field.value}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="text">Текст</SelectItem>
                    <SelectItem value="number">Число</SelectItem>
                    <SelectItem value="select">Выбор</SelectItem>
                  </SelectContent>
                </Select>
              </FormItem>
            )}
          />

          {/* Show only for select type */}
          {columnType === 'select' && (
            <FormField
              control={form.control}
              name="options"
              render={() => (
                <FormItem>
                  <FormLabel>Варианты выбора</FormLabel>
                  <OptionsEditor
                    value={form.watch('options') || []}
                    onChange={(opts) => form.setValue('options', opts)}
                  />
                </FormItem>
              )}
            />
          )}

          <Button type="submit">Сохранить</Button>
        </form>
      </Form>
    );
  }
  ```

- **Form State Management:**

  **1. Dirty State Handling**
  ```typescript
  function EditProjectForm({ project }: { project: Project }) {
    const form = useForm<ProjectFormData>({
      resolver: zodResolver(projectSchema),
      defaultValues: project,
    });

    // Warn before leaving if form is dirty
    useEffect(() => {
      const handleBeforeUnload = (e: BeforeUnloadEvent) => {
        if (form.formState.isDirty) {
          e.preventDefault();
          e.returnValue = '';
        }
      };

      window.addEventListener('beforeunload', handleBeforeUnload);

      return () => {
        window.removeEventListener('beforeunload', handleBeforeUnload);
      };
    }, [form.formState.isDirty]);

    return (
      <Form {...form}>
        {/* Form fields */}

        {form.formState.isDirty && (
          <div className="text-sm text-warning">
            У вас есть несохраненные изменения
          </div>
        )}
      </Form>
    );
  }
  ```

  **2. Reset After Submit**
  ```typescript
  const handleSubmit = async (data: FormData) => {
    try {
      await onSubmit(data);

      // Reset form to new default values
      form.reset({
        name: '',
        description: '',
        is_public: false,
      });

      toast.success('Проект создан');
    } catch (error) {
      toast.error('Ошибка создания проекта');
    }
  };
  ```

- **File Upload in Forms:**

  **1. Single File Upload**
  ```typescript
  const fileSchema = z.object({
    name: z.string(),
    file: z.instanceof(File, { message: 'Выберите файл' })
      .refine(file => file.size <= 5 * 1024 * 1024, 'Максимум 5MB')
      .refine(
        file => ['image/jpeg', 'image/png', 'application/pdf'].includes(file.type),
        'Только JPG, PNG или PDF'
      ),
  });

  function FileUploadForm() {
    const form = useForm<FileFormData>({
      resolver: zodResolver(fileSchema),
    });

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (file) {
        form.setValue('file', file, { shouldValidate: true });
      }
    };

    return (
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <FormField
            control={form.control}
            name="file"
            render={() => (
              <FormItem>
                <FormLabel>Файл</FormLabel>
                <FormControl>
                  <input
                    type="file"
                    accept="image/jpeg,image/png,application/pdf"
                    onChange={handleFileChange}
                    className="file:mr-4 file:px-4 file:py-2 file:rounded file:border-0 file:bg-primary file:text-primary-foreground"
                  />
                </FormControl>
                <FormDescription>
                  Максимум 5MB, JPG, PNG или PDF
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <Button type="submit">Загрузить</Button>
        </form>
      </Form>
    );
  }
  ```

  **2. Drag & Drop Upload**
  Reference: [UploadZone.tsx](mdc:src/components/UploadZone.tsx)

  ```typescript
  import { useCallback } from 'react';
  import { Upload } from 'lucide-react';

  function DragDropUpload({ onFilesSelected }: {
    onFilesSelected: (files: File[]) => void;
  }) {
    const [isDragging, setIsDragging] = useState(false);

    const handleDrop = useCallback((e: React.DragEvent) => {
      e.preventDefault();
      setIsDragging(false);

      const files = Array.from(e.dataTransfer.files);
      onFilesSelected(files);
    }, [onFilesSelected]);

    const handleDragOver = useCallback((e: React.DragEvent) => {
      e.preventDefault();
      setIsDragging(true);
    }, []);

    return (
      <div
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={() => setIsDragging(false)}
        className={cn(
          "border-2 border-dashed rounded-lg p-8 text-center transition-colors",
          isDragging ? "border-primary bg-primary/10" : "border-border"
        )}
      >
        <Upload className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
        <p className="text-sm text-muted-foreground">
          Перетащите файлы сюда или нажмите для выбора
        </p>
        <input
          type="file"
          multiple
          className="hidden"
          onChange={(e) => onFilesSelected(Array.from(e.target.files || []))}
        />
      </div>
    );
  }
  ```

- **Multi-Step Forms (Wizards):**

  **1. Step-by-Step Form**
  Reference: [ImportModeSelector.tsx](mdc:src/components/import/ImportModeSelector.tsx)

  ```typescript
  import { useState } from 'react';
  import { Button } from '@/components/ui/button';
  import { ChevronLeft, ChevronRight } from 'lucide-react';

  type StepData = {
    step1: Step1Data;
    step2: Step2Data;
    step3: Step3Data;
  };

  function MultiStepForm() {
    const [currentStep, setCurrentStep] = useState(1);
    const [formData, setFormData] = useState<Partial<StepData>>({});

    const form = useForm({
      resolver: zodResolver(getCurrentSchema(currentStep)),
      defaultValues: formData[`step${currentStep}`],
    });

    const handleNext = async () => {
      const isValid = await form.trigger();

      if (isValid) {
        setFormData(prev => ({
          ...prev,
          [`step${currentStep}`]: form.getValues(),
        }));

        if (currentStep < 3) {
          setCurrentStep(prev => prev + 1);
        } else {
          // Submit final form
          await handleSubmit(formData);
        }
      }
    };

    const handleBack = () => {
      setFormData(prev => ({
        ...prev,
        [`step${currentStep}`]: form.getValues(),
      }));
      setCurrentStep(prev => prev - 1);
    };

    return (
      <div className="space-y-6">
        {/* Progress indicator */}
        <div className="flex items-center justify-between">
          {[1, 2, 3].map(step => (
            <div
              key={step}
              className={cn(
                "flex-1 h-2 rounded",
                step <= currentStep ? "bg-primary" : "bg-muted"
              )}
            />
          ))}
        </div>

        {/* Step content */}
        <Form {...form}>
          {currentStep === 1 && <Step1 />}
          {currentStep === 2 && <Step2 />}
          {currentStep === 3 && <Step3 />}

          {/* Navigation */}
          <div className="flex justify-between">
            <Button
              type="button"
              variant="outline"
              onClick={handleBack}
              disabled={currentStep === 1}
            >
              <ChevronLeft className="h-4 w-4 mr-2" />
              Назад
            </Button>

            <Button type="button" onClick={handleNext}>
              {currentStep === 3 ? 'Завершить' : 'Далее'}
              {currentStep < 3 && <ChevronRight className="h-4 w-4 ml-2" />}
            </Button>
          </div>
        </Form>
      </div>
    );
  }
  ```

- **Form Error Handling:**

  **1. Field-Level Errors**
  ```typescript
  // ✅ DO: Show errors below fields
  <FormField
    control={form.control}
    name="email"
    render={({ field, fieldState }) => (
      <FormItem>
        <FormLabel>Email</FormLabel>
        <FormControl>
          <Input
            {...field}
            className={cn(fieldState.error && "border-destructive")}
          />
        </FormControl>
        <FormMessage /> {/* Автоматически показывает ошибку */}
      </FormItem>
    )}
  />
  ```

  **2. Form-Level Errors**
  ```typescript
  const handleSubmit = async (data: FormData) => {
    try {
      await createProject(data);
    } catch (error) {
      if (error instanceof ApiError) {
        // Set form-level error
        form.setError('root', {
          type: 'manual',
          message: error.message,
        });

        // Or field-specific error
        if (error.code === 'duplicate_name') {
          form.setError('name', {
            type: 'manual',
            message: 'Проект с таким именем уже существует',
          });
        }
      }
    }
  };

  // Display root error
  {form.formState.errors.root && (
    <Alert variant="destructive">
      <AlertDescription>
        {form.formState.errors.root.message}
      </AlertDescription>
    </Alert>
  )}
  ```

- **Form Performance:**

  **1. Avoid Unnecessary Re-renders**
  ```typescript
  // ✅ DO: Use isolated field components
  const EmailField = ({ control }: { control: Control<FormData> }) => (
    <FormField
      control={control}
      name="email"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Email</FormLabel>
          <FormControl>
            <Input {...field} />
          </FormControl>
        </FormItem>
      )}
    />
  );

  // Entire component doesn't re-render when email changes
  ```

  **2. Debounce Expensive Validation**
  ```typescript
  const name = form.watch('name');
  const debouncedName = useDebounce(name, 300);

  useEffect(() => {
    if (debouncedName) {
      validateName(debouncedName);
    }
  }, [debouncedName]);
  ```

Follow [react_components.mdc](mdc:.cursor/rules/react_components.mdc) for component patterns.
Follow [typescript.mdc](mdc:.cursor/rules/typescript.mdc) for type safety with Zod.
