import { serve } from 'https://deno.land/std@0.190.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.75.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? ''
    );

    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    const { data: { user } } = await supabase.auth.getUser(token);

    if (!user) {
      throw new Error('Unauthorized');
    }

    const { templateId, format, data, config } = await req.json();

    console.log('Generating report:', { templateId, format, userId: user.id });

    // Generate report based on format
    let reportContent: BodyInit;
    let contentType: string;
    let filename: string;
    const reportName = data?.name || 'report';

    if (format === 'pdf') {
      contentType = 'application/pdf';
      filename = `${reportName}-${Date.now()}.pdf`;
      reportContent = await generatePDFReport(data, config);
    } else if (format === 'excel' || format === 'xlsx') {
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
      filename = `${reportName}-${Date.now()}.xlsx`;
      reportContent = await generateExcelReport(data);
    } else if (format === 'csv') {
      contentType = 'text/csv';
      filename = `${reportName}-${Date.now()}.csv`;
      reportContent = generateCSVContent(data);
    } else {
      contentType = 'text/html';
      filename = `${reportName}-${Date.now()}.html`;
      reportContent = generateHTMLContent(data);
    }

    return new Response(reportContent, {
      headers: {
        ...corsHeaders,
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
    });
  } catch (error) {
    console.error('Report generation error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return new Response(
      JSON.stringify({ error: errorMessage }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});

async function generatePDFReport(data: any, config: any): Promise<BodyInit> {
  // Import jsPDF dynamically
  const { default: jsPDF } = await import('https://esm.sh/jspdf@2.5.1');
  
  const doc = new jsPDF();
  const rows = data?.rows || [];
  const title = data?.name || 'Report';
  const date = new Date().toLocaleDateString('ru-RU');
  
  // Add header
  doc.setFontSize(20);
  doc.text(title, 20, 20);
  
  doc.setFontSize(10);
  doc.text(`Generated: ${date}`, 20, 30);
  doc.text(`Records: ${rows.length}`, 20, 35);
  
  // Add line separator
  doc.setLineWidth(0.5);
  doc.line(20, 40, 190, 40);
  
  let yPosition = 50;
  
  // Add table if data exists
  if (rows.length > 0) {
    const headers = Object.keys(rows[0]);
    const maxCols = Math.min(headers.length, 5); // Limit columns to fit page
    const colWidth = 170 / maxCols;
    
    // Table headers
    doc.setFontSize(9);
    doc.setFont(undefined, 'bold');
    headers.slice(0, maxCols).forEach((header, i) => {
      doc.text(header, 20 + (i * colWidth), yPosition);
    });
    
    yPosition += 7;
    doc.setFont(undefined, 'normal');
    
    // Table rows (limit to first 30 rows to fit page)
    const maxRows = Math.min(rows.length, 30);
    for (let i = 0; i < maxRows; i++) {
      const row = rows[i];
      headers.slice(0, maxCols).forEach((header, j) => {
        const value = String(row[header] ?? '');
        const truncated = value.length > 20 ? value.substring(0, 17) + '...' : value;
        doc.text(truncated, 20 + (j * colWidth), yPosition);
      });
      yPosition += 6;
      
      // Add new page if needed
      if (yPosition > 270) {
        doc.addPage();
        yPosition = 20;
      }
    }
    
    if (rows.length > maxRows) {
      yPosition += 5;
      doc.setFontSize(8);
      doc.text(`... and ${rows.length - maxRows} more records`, 20, yPosition);
    }
  }
  
  // Add footer
  const pageCount = doc.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.text(
      `Page ${i} of ${pageCount} | Generated by VHData Platform`,
      20,
      285
    );
  }
  
  return doc.output('arraybuffer');
}

async function generateExcelReport(data: any): Promise<BodyInit> {
  // Import ExcelJS dynamically
  const ExcelJS = await import('https://esm.sh/exceljs@4.4.0');
  
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Report');
  const rows = data?.rows || [];
  
  if (rows.length > 0) {
    const headers = Object.keys(rows[0]);
    
    // Add title row
    worksheet.mergeCells('A1', `${String.fromCharCode(65 + headers.length - 1)}1`);
    const titleCell = worksheet.getCell('A1');
    titleCell.value = data?.name || 'Report';
    titleCell.font = { size: 16, bold: true };
    titleCell.alignment = { vertical: 'middle', horizontal: 'center' };
    worksheet.getRow(1).height = 30;
    
    // Add metadata row
    worksheet.mergeCells('A2', `${String.fromCharCode(65 + headers.length - 1)}2`);
    const metaCell = worksheet.getCell('A2');
    metaCell.value = `Generated: ${new Date().toLocaleString('ru-RU')} | Records: ${rows.length}`;
    metaCell.font = { size: 10, italic: true };
    metaCell.alignment = { vertical: 'middle', horizontal: 'center' };
    
    // Add empty row
    worksheet.addRow([]);
    
    // Add headers
    const headerRow = worksheet.addRow(headers);
    headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4CAF50' },
    };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.height = 25;
    
    // Add data rows
    rows.forEach((row: any) => {
      const dataRow = worksheet.addRow(headers.map(h => row[h]));
      dataRow.alignment = { vertical: 'middle' };
    });
    
    // Auto-fit columns
    worksheet.columns.forEach((column, i) => {
      let maxLength = headers[i].length;
      column.eachCell?.({ includeEmpty: false }, (cell) => {
        const cellLength = String(cell.value ?? '').length;
        if (cellLength > maxLength) {
          maxLength = cellLength;
        }
      });
      column.width = Math.min(Math.max(maxLength + 2, 10), 50);
    });
    
    // Add borders to data table
    const dataRange = `A4:${String.fromCharCode(65 + headers.length - 1)}${rows.length + 4}`;
    worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
      if (rowNumber >= 4) {
        row.eachCell((cell) => {
          cell.border = {
            top: { style: 'thin' },
            left: { style: 'thin' },
            bottom: { style: 'thin' },
            right: { style: 'thin' },
          };
        });
      }
    });
  }
  
  const buffer = await workbook.xlsx.writeBuffer();
  return new Uint8Array(buffer);
}

function generateCSVContent(data: any): string {
  const rows = data?.rows || [];
  if (rows.length === 0) {
    return 'No data';
  }

  const headers = Object.keys(rows[0]);
  
  // Escape CSV values
  const escape = (value: any) => {
    const str = String(value ?? '');
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
      return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
  };

  let csv = headers.map(escape).join(',') + '\n';
  rows.forEach((row: any) => {
    csv += headers.map(h => escape(row[h])).join(',') + '\n';
  });
  
  return csv;
}

function generateHTMLContent(data: any): string {
  const rows = data?.rows || [];
  const title = data?.name || 'Report';
  const headers = rows.length > 0 ? Object.keys(rows[0]) : [];
  
  let html = `<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      padding: 40px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 8px;
      font-size: 28px;
    }
    .meta {
      color: #666;
      margin-bottom: 32px;
      font-size: 14px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 24px;
    }
    th, td {
      border: 1px solid #e0e0e0;
      padding: 12px 16px;
      text-align: left;
    }
    th {
      background-color: #4CAF50;
      color: white;
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    tr:hover {
      background-color: #f0f0f0;
    }
    td {
      font-size: 14px;
      color: #333;
    }
    .footer {
      margin-top: 32px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
      color: #999;
      font-size: 12px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>${title}</h1>
    <div class="meta">
      Создан: ${new Date().toLocaleString('ru-RU')} | 
      Записей: ${rows.length}
    </div>
    <table>
      <thead>
        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
      </thead>
      <tbody>`;
  
  rows.forEach((row: any) => {
    html += `<tr>${headers.map(h => `<td>${row[h] ?? ''}</td>`).join('')}</tr>`;
  });
  
  html += `</tbody>
    </table>
    <div class="footer">
      Generated by VHData Platform
    </div>
  </div>
</body>
</html>`;
  
  return html;
}